# ch 15. 구글 드라이브 설계
### watchdog
- 이 코드는 Linux에서는 inotify, macOS에서는 FSEvents, Windows에서는 ReadDirectoryChangesW를 자동으로 사용하여 파일 변경 사항을 감지합니다.
```python
import time
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

class MyHandler(FileSystemEventHandler):
    def on_modified(self, event):
        if not event.is_directory:
            print(f"파일 수정됨: {event.src_path}")

    def on_created(self, event):
        print(f"파일 생성됨: {event.src_path}")

    def on_deleted(self, event):
        print(f"파일 삭제됨: {event.src_path}")

path = "/Users/myfolder"  # 감시할 디렉터리
observer = Observer()
observer.schedule(MyHandler(), path, recursive=True)
observer.start()

try:
    while True:
        time.sleep(1)
except KeyboardInterrupt:
    observer.stop()
observer.join()
```

## AWS S3 파일 동시성 이슈
```
S3에서 두 클라이언트가 동시에 같은 파일에 쓰기를 요청할 경우, "마지막 작성자 승리(Last Writer Wins)" 방식으로 처리됩니다. 구체적으로:

시간적으로 나중에 완료된 요청이 이김:

가장 마지막에 처리된 PUT 요청이 최종 상태가 됩니다
먼저 시작했더라도 나중에 완료된 요청이 우선합니다
이전 쓰기 내용은 덮어씌워집니다


데이터 손실 가능성:

첫 번째 클라이언트의 변경사항이 두 번째 클라이언트에 의해 완전히 덮어씌워질 수 있습니다
부분 업데이트 개념이 없어 전체 객체가 대체됩니다


순차적 일관성 보장 없음:

S3는 원자적 트랜잭션을 보장하지 않습니다
쓰기 충돌 해결을 자동으로 처리하지 않습니다



이러한 동시 쓰기 문제를 방지하기 위한 일반적인 접근 방법:

버전 관리 활성화: 모든 쓰기 버전이 보존됩니다
조건부 쓰기 사용: If-Match 또는 If-None-Match 헤더로 변경 감지
DynamoDB와 함께 잠금 메커니즘 구현: 외부 락 시스템 활용
객체 잠금 사용: 특정 기간 동안 객체 수정 방지
고유 파일명 사용: 타임스탬프나 UUID를 파일명에 포함

응용 프로그램이 동시 쓰기에 민감하다면, 이러한 방법 중 하나 이상을 구현하여 데이터 일관성을 유지하는 것이 좋습니다.
```

# ch 16.
- https://docs.all-hands.dev/modules/usage/architecture/backend

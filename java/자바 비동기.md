## 자바 비동기
```java
public class AsyncExample {
    public static void main(String[] args) {
        Runnable task = () -> {
            try {
                Thread.sleep(2000); // 2초 대기
                System.out.println("비동기 작업 완료!");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        };

        Thread thread = new Thread(task);
        thread.start(); // 비동기 실행
        System.out.println("메인 스레드는 계속 실행됩니다.");
    }
}
```
- 예를 들어, 이 코드를 실행하면 CPU 는 thread 를 스케쥴링해서 동시 처리한다.

## i/o bound vs. cpu bound
- i/o bound 는 io 가 많아서 cpu 가 놀고 있는 상태로, cpu bound 는 cpu 사용량이 높은 상태다.
- 여기서 i/o 란 무엇일까?
- 저장 장치	HDD, SSD, USB	파일 데이터를 읽거나 저장
- 네트워크 장치	Ethernet 카드, Wi-Fi 어댑터	네트워크 데이터를 송수신

| 구성 요소                 | 역할                                                                                      |
|--------------------------|------------------------------------------------------------------------------------------|
| **CPU (중앙처리장치)**    | - I/O 작업을 시작(요청)하고, 작업이 완료되었는지 확인.                                      |
|                          | - 데이터 전송 중 I/O 장치와 메모리 간의 제어를 수행(필요 시).                               |
|                          | - 파일 읽기, 네트워크 요청 등 I/O 요청을 시스템 콜을 통해 커널에 전달.                      |
|                          | - 작업 완료 후, 결과를 처리.                                                               |
| **I/O 컨트롤러**          | - I/O 장치(예: 디스크, 네트워크 카드 등)를 제어.                                            |
|                          | - CPU의 명령에 따라 데이터 전송 작업을 수행.                                               |
|                          | - 데이터 전송이 끝나면 **인터럽트(Interrupt)**를 통해 CPU에 완료 신호를 보냄.               |
| **I/O 장치 (디바이스)**   | - 데이터를 실제로 읽거나 쓰는 작업을 수행.                                                  |
|                          | - 예: 디스크 드라이브가 파일을 읽거나, 네트워크 카드가 패킷을 송수신.                        |
| **DMA (Direct Memory Access)** | - CPU 개입 없이 I/O 장치가 메모리와 직접 데이터를 주고받도록 함.                           |
|                          | - 대량의 데이터 전송 시 CPU의 부하를 줄이는 데 사용.                                        |

### io 가 매우 많을 경우 cpu 사용량이 증가하는 원인

1. **시스템 콜 오버헤드**  
   - 각 I/O 작업은 시스템 콜을 통해 OS 커널에 요청됩니다.  
   - 소용량 I/O 작업이 많으면, 시스템 콜이 자주 발생하여 **컨텍스트 스위칭**(User Mode ↔ Kernel Mode)이 빈번해지고, CPU가 이를 처리하느라 부하가 증가합니다.  
   - **예**: `read()`, `write()` 호출이 많을수록 CPU는 커널로 전환하는 데 더 많은 시간을 사용.

2. **인터럽트 처리**  
   - I/O 장치에서 **인터럽트(Interrupt)**를 발생시켜 CPU가 작업 완료를 확인하고 다음 작업을 처리합니다.  
   - 소용량 I/O가 많으면 **인터럽트 발생 빈도**가 증가하여 CPU가 이를 처리하느라 부하가 늘어납니다.

3. **데이터 복사 작업**  
   - I/O 작업 시, **I/O 버퍼와 메모리 간의 데이터 복사**가 필요합니다.  
   - 소용량 데이터를 반복적으로 복사하면 CPU가 이러한 작업에 더 많은 시간을 소모하게 됩니다.

4. **I/O 대기 및 스케줄링 오버헤드**  
   - I/O 작업이 많아지면 CPU는 각 작업을 **스케줄링**하고 처리 대기를 관리해야 합니다.  
   - 작업 수가 많아질수록 CPU가 스케줄링에 사용하는 리소스도 증가합니다.

### **AWS에서 Disk I/O와 Network I/O 성능 향상 요약**

#### **Disk I/O 성능 향상**
1. **스토리지 종류 선택**
   - `gp3`: 일반적인 워크로드.
   - `io2`: 고성능 IOPS 요구.
   - `Instance Store`: 짧은 지연 시간, 고속 I/O.

2. **EBS 최적화 활성화**
   - 전용 네트워크 대역폭으로 I/O 성능 향상.

3. **RAID 0 구성**
   - 여러 EBS 볼륨 묶어 성능 향상.

4. **디스크 크기 조정**
   - 볼륨 크기 증가 시 IOPS와 처리량 증가.

#### **Network I/O 성능 향상**
1. **인스턴스 업그레이드**
   - `c5n`, `m5n`: 고성능 네트워크 지원.

2. **Enhanced Networking 활성화**
   - 네트워크 지연 감소, CPU 부하 줄임.

3. **Elastic Fabric Adapter (EFA)**
   - HPC 워크로드에서 초저지연 네트워크 제공.

4. **VPC Peering / Direct Connect**
   - 빠르고 안정적인 네트워크 연결.

#### **모니터링**
- **CloudWatch Metrics**로 Disk I/O(`VolumeReadOps`, `VolumeWriteOps`)와 Network I/O(`NetworkIn`, `NetworkOut`) 확인.

#### **최적화**
- 스토리지와 인스턴스 유형 적절히 선택.
- 데이터 압축, 캐싱 활용.

### **I/O Bound의 특징**
- 작업 병목이 **I/O 대기 시간**(디스크, 네트워크)에서 발생.
- CPU는 대기 상태가 많아, **병렬 작업 실행 여유**가 있음.

### **Thread Pool의 장점**
1. **I/O 대기 시간 동안 CPU 활용**  
   - I/O 대기 중 다른 스레드로 작업 처리 → **동시성 향상**, 자원 활용 극대화.
   
2. **스레드 생성 비용 절감**  
   - 스레드 재사용으로 **생성/소멸 오버헤드 감소**.

3. **스레드 관리 최적화**  
   - **최대 스레드 수 제한**으로 안정성과 성능 보장.

### **Thread Pool이 효과적인 경우**
- **I/O Bound 작업**: 파일 읽기/쓰기, 네트워크 요청, DB 접근 등.  
- **예**:  
   - 다수 클라이언트 요청 처리(웹 서버).  
   - 비동기 데이터베이스 쿼리.


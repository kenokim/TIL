## ch02. 아키텍처 개요
- 엔터프라이즈 애플리케이션 아키텍처 패턴 - 마틴 파울러
- DDD - 에릭 에반스
- 도메인 모델 패턴 : 비즈니스 로직이 도메인 모델에 있다.

## 2.2 DIP
- https://en.wikipedia.org/wiki/Dependency_inversion_principle
- SOLID 설계 원칙, 경험적으로 이러한 원칙에 따라 소프트웨어를 설계했을 때 좋은 구조가 된다.
- 고수준은 저수준에 의존해서는 안되고, 추상화에 의존해야 한다.

```java
// DIP 를 위배하는 코드
public class UserRepository {
    public User findById(Long id) {
        return jdbcTemplate.query("SELECT * FROM user WHERE user.id = ?;");
    }
}

// DIP 를 지키는 코드
public interface UserRepository {
    User findById(Long id);
}

```
- 위의 코드는 고수준 (service) 이 저수준 (infrastructure) 를 의존하게 되며, 따라서 DIP 에 위배된다.
    - 테스트 용이성이 낮다. config 코드가 붙어 있다.
    - DB 접근 기술이나 DB 를 바꾸기 어렵다.
- 밑의 코드는 저수준 (infrastructure) 가 고수준 (UserRepositry) 에 의존하며, 필요 시 구현체를 바꾸면 되므로 유연하다.

### 생각해보기
```java
public UserResponse findUserById(Long id) {
    return UserResponse.of(userRepository.findById(id));
}
```
- 이 코드는 DIP 를 위배한다. 고수준인 Service 계층이 저수준의 Presentation 계층에 의존한다.
- 이 코드가 좋은 코드일까?

- 생각: DIP 를 지키려면 interface 를 service 계층에 추가해서 UserResponse 객체가 구현하도록 하면 된다.
- 그렇게 되면 service 는 Response 가 of 를 쓰던, from 을 쓰던, to 를 쓰던 알 필요가 없고 결합도가 낮아지는 좋은 코드가 된다.
- 그러나 interface 가 추가되고, interface 를 바꾸기 힘들어지며 코드의 복잡도가 올라간다.  
- 이를 해결할 방법? 컨밴션을 통해 of 만 쓰자고 정하면 된다.

## 2.4 도메인 모델이란
- 엔티티, 밸류, 애그리거트, 리포지토리, 도메인 서비스
### Entity
- DB table entity (ERD) vs. domain model entity
- entity vs. value -> entity 는 ID 에 의해 식별된다. value 는 식별되지 않는다.
- value 의 장점: 캡슐화, 객체지향 composition -> 코드 재사용, 표현력, 비즈니스 로직 응집도
- 엔티티란? clean architecture : 비즈니스 데이터와 비즈니스 로직을 모듈화 한 것
- 다른 ddd책: 애그리게이트 패턴의 컨텍스트에서만 엔티티를 구현한다.
- eric evans 책 : An object defined primarily by its identity is called an ENTITY.

### Aggregate
- 패턴, 어떤 개념인지 볼 것
